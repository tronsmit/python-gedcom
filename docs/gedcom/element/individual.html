<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>gedcom.element.individual API documentation</title>
<meta name="description" content="GEDCOM element consisting of tag `gedcom.tags.GEDCOM_TAG_INDIVIDUAL`" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gedcom.element.individual</code></h1>
</header>
<section id="section-intro">
<p>GEDCOM element consisting of tag <a title="gedcom.tags.GEDCOM_TAG_INDIVIDUAL" href="../tags.html#gedcom.tags.GEDCOM_TAG_INDIVIDUAL"><code>GEDCOM_TAG_INDIVIDUAL</code></a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# Python GEDCOM Parser
#
# Copyright (C) 2018 Damon Brodie (damon.brodie at gmail.com)
# Copyright (C) 2018-2019 Nicklas Reincke (contact at reynke.com)
# Copyright (C) 2016 Andreas Oberritter
# Copyright (C) 2012 Madeleine Price Ball
# Copyright (C) 2005 Daniel Zappala (zappala at cs.byu.edu)
# Copyright (C) 2005 Brigham Young University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Further information about the license: http://www.gnu.org/licenses/gpl-2.0.html

&#34;&#34;&#34;GEDCOM element consisting of tag `gedcom.tags.GEDCOM_TAG_INDIVIDUAL`&#34;&#34;&#34;

import re as regex
from gedcom.element.element import Element
from gedcom.helpers import deprecated
import gedcom.tags


class NotAnActualIndividualError(Exception):
    pass


class IndividualElement(Element):

    def get_tag(self):
        return gedcom.tags.GEDCOM_TAG_INDIVIDUAL

    def is_deceased(self):
        &#34;&#34;&#34;Checks if this individual is deceased
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                return True

        return False

    def is_child(self):
        &#34;&#34;&#34;Checks if this element is a child of a family
        :rtype: bool
        &#34;&#34;&#34;
        found_child = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_FAMILY_CHILD:
                found_child = True

        return found_child

    def is_private(self):
        &#34;&#34;&#34;Checks if this individual is marked private
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_PRIVATE:
                private = child.get_value()
                if private == &#39;Y&#39;:
                    return True

        return False

    def get_name(self):
        &#34;&#34;&#34;Returns an individual&#39;s names as a tuple: (`str` given_name, `str` surname)
        :rtype: tuple
        &#34;&#34;&#34;
        given_name = &#34;&#34;
        surname = &#34;&#34;

        # Return the first gedcom.tags.GEDCOM_TAG_NAME that is found.
        # Alternatively as soon as we have both the gedcom.tags.GEDCOM_TAG_GIVEN_NAME and _SURNAME return those.
        found_given_name = False
        found_surname_name = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_NAME:
                # Some GEDCOM files don&#39;t use child tags but instead
                # place the name in the value of the NAME tag.
                if child.get_value() != &#34;&#34;:
                    name = child.get_value().split(&#39;/&#39;)

                    if len(name) &gt; 0:
                        given_name = name[0].strip()
                        if len(name) &gt; 1:
                            surname = name[1].strip()

                    return given_name, surname

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_GIVEN_NAME:
                        given_name = childOfChild.get_value()
                        found_given_name = True

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SURNAME:
                        surname = childOfChild.get_value()
                        found_surname_name = True

                if found_given_name and found_surname_name:
                    return given_name, surname

        # If we reach here we are probably returning empty strings
        return given_name, surname

    def get_all_names(self):
        return [a.get_value() for a in self.get_child_elements() if a.get_tag() == gedcom.tags.GEDCOM_TAG_NAME]

    def surname_match(self, surname_to_match):
        &#34;&#34;&#34;Matches a string with the surname of an individual
        :type surname_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(surname_to_match, surname, regex.IGNORECASE)

    @deprecated
    def given_match(self, name):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        ::deprecated:: As of version 1.0.0 use `given_name_match()` method instead
        :type name: str
        :rtype: bool
        &#34;&#34;&#34;
        return self.given_name_match(name)

    def given_name_match(self, given_name_to_match):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        :type given_name_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(given_name_to_match, given_name, regex.IGNORECASE)

    def get_gender(self):
        &#34;&#34;&#34;Returns the gender of a person in string format
        :rtype: str
        &#34;&#34;&#34;
        gender = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_SEX:
                gender = child.get_value()

        return gender

    def get_birth_data(self):
        &#34;&#34;&#34;Returns the birth data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_birth_year(self):
        &#34;&#34;&#34;Returns the birth year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    def get_death_data(self):
        &#34;&#34;&#34;Returns the death data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_death_year(self):
        &#34;&#34;&#34;Returns the death year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    @deprecated
    def get_burial(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_burial_data()` method instead
        :rtype: tuple
        &#34;&#34;&#34;
        self.get_burial_data()

    def get_burial_data(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BURIAL:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    @deprecated
    def get_census(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_census_data()` method instead
        :rtype: list of tuple
        &#34;&#34;&#34;
        self.get_census_data()

    def get_census_data(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        :rtype: list of tuple
        &#34;&#34;&#34;
        census = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CENSUS:

                date = &#39;&#39;
                place = &#39;&#39;
                sources = []

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

                census.append((date, place, sources))

        return census

    def get_last_change_date(self):
        &#34;&#34;&#34;Returns the date of when the person data was last changed formatted as a string
        :rtype: str
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CHANGE:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

        return date

    def get_occupation(self):
        &#34;&#34;&#34;Returns the occupation of a person
        :rtype: str
        &#34;&#34;&#34;
        occupation = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_OCCUPATION:
                occupation = child.get_value()

        return occupation

    def birth_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the birth year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_birth_year() == year

    def birth_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the birth year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        birth_year = self.get_birth_year()

        if from_year &lt;= birth_year &lt;= to_year:
            return True

        return False

    def death_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the death year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_death_year() == year

    def death_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the death year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        death_year = self.get_death_year()

        if from_year &lt;= death_year &lt;= to_year:
            return True

        return False

    def criteria_match(self, criteria):
        &#34;&#34;&#34;Checks if this individual matches all of the given criteria

        `criteria` is a colon-separated list, where each item in the
        list has the form [name]=[value]. The following criteria are supported:

        surname=[name]
             Match a person with [name] in any part of the `surname`.
        given_name=[given_name]
             Match a person with [given_name] in any part of the given `given_name`.
        birth=[year]
             Match a person whose birth year is a four-digit [year].
        birth_range=[from_year-to_year]
             Match a person whose birth year is in the range of years from
             [from_year] to [to_year], including both [from_year] and [to_year].

        :type criteria: str
        :rtype: bool
        &#34;&#34;&#34;

        # Check if criteria is a valid criteria and can be split by `:` and `=` characters
        try:
            for criterion in criteria.split(&#39;:&#39;):
                criterion.split(&#39;=&#39;)
        except ValueError:
            return False

        match = True

        for criterion in criteria.split(&#39;:&#39;):
            key, value = criterion.split(&#39;=&#39;)

            if key == &#34;surname&#34; and not self.surname_match(value):
                match = False
            elif key == &#34;name&#34; and not self.given_name_match(value):
                match = False
            elif key == &#34;birth&#34;:

                try:
                    year = int(value)
                    if not self.birth_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;birth_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.birth_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death&#34;:

                try:
                    year = int(value)
                    if not self.death_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.death_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

        return match</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gedcom.element.individual.IndividualElement"><code class="flex name class">
<span>class <span class="ident">IndividualElement</span></span>
<span>(</span><span>level, pointer, tag, value, crlf='\n', multi_line=True)</span>
</code></dt>
<dd>
<section class="desc"><p>GEDCOM element</p>
<p>Each line in a GEDCOM file is an element with the format</p>
<p><code>level [pointer] tag [value]</code></p>
<p>where <code>level</code> and <code>tag</code> are required, and <code>pointer</code> and <code>value</code> are
optional.
Elements are arranged hierarchically according to their
level, and elements with a level of zero are at the top level.
Elements with a level greater than zero are children of their
parent.</p>
<p>A pointer has the format <code>@pname@</code>, where <code>pname</code> is any sequence of
characters and numbers. The pointer identifies the object being
pointed to, so that any pointer included as the value of any
element points back to the original object.
For example, an
element may have a <code>FAMS</code> tag whose value is <code>@F1@</code>, meaning that this
element points to the family record in which the associated person
is a spouse. Likewise, an element with a tag of <code>FAMC</code> has a value
that points to a family record in which the associated person is a
child.</p>
<p>See a GEDCOM file for examples of tags and their values.</p>
<p>Tags available to an element are seen here: <a title="gedcom.tags" href="../tags.html"><code>gedcom.tags</code></a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndividualElement(Element):

    def get_tag(self):
        return gedcom.tags.GEDCOM_TAG_INDIVIDUAL

    def is_deceased(self):
        &#34;&#34;&#34;Checks if this individual is deceased
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                return True

        return False

    def is_child(self):
        &#34;&#34;&#34;Checks if this element is a child of a family
        :rtype: bool
        &#34;&#34;&#34;
        found_child = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_FAMILY_CHILD:
                found_child = True

        return found_child

    def is_private(self):
        &#34;&#34;&#34;Checks if this individual is marked private
        :rtype: bool
        &#34;&#34;&#34;
        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_PRIVATE:
                private = child.get_value()
                if private == &#39;Y&#39;:
                    return True

        return False

    def get_name(self):
        &#34;&#34;&#34;Returns an individual&#39;s names as a tuple: (`str` given_name, `str` surname)
        :rtype: tuple
        &#34;&#34;&#34;
        given_name = &#34;&#34;
        surname = &#34;&#34;

        # Return the first gedcom.tags.GEDCOM_TAG_NAME that is found.
        # Alternatively as soon as we have both the gedcom.tags.GEDCOM_TAG_GIVEN_NAME and _SURNAME return those.
        found_given_name = False
        found_surname_name = False

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_NAME:
                # Some GEDCOM files don&#39;t use child tags but instead
                # place the name in the value of the NAME tag.
                if child.get_value() != &#34;&#34;:
                    name = child.get_value().split(&#39;/&#39;)

                    if len(name) &gt; 0:
                        given_name = name[0].strip()
                        if len(name) &gt; 1:
                            surname = name[1].strip()

                    return given_name, surname

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_GIVEN_NAME:
                        given_name = childOfChild.get_value()
                        found_given_name = True

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SURNAME:
                        surname = childOfChild.get_value()
                        found_surname_name = True

                if found_given_name and found_surname_name:
                    return given_name, surname

        # If we reach here we are probably returning empty strings
        return given_name, surname

    def get_all_names(self):
        return [a.get_value() for a in self.get_child_elements() if a.get_tag() == gedcom.tags.GEDCOM_TAG_NAME]

    def surname_match(self, surname_to_match):
        &#34;&#34;&#34;Matches a string with the surname of an individual
        :type surname_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(surname_to_match, surname, regex.IGNORECASE)

    @deprecated
    def given_match(self, name):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        ::deprecated:: As of version 1.0.0 use `given_name_match()` method instead
        :type name: str
        :rtype: bool
        &#34;&#34;&#34;
        return self.given_name_match(name)

    def given_name_match(self, given_name_to_match):
        &#34;&#34;&#34;Matches a string with the given name of an individual
        :type given_name_to_match: str
        :rtype: bool
        &#34;&#34;&#34;
        (given_name, surname) = self.get_name()
        return regex.search(given_name_to_match, given_name, regex.IGNORECASE)

    def get_gender(self):
        &#34;&#34;&#34;Returns the gender of a person in string format
        :rtype: str
        &#34;&#34;&#34;
        gender = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_SEX:
                gender = child.get_value()

        return gender

    def get_birth_data(self):
        &#34;&#34;&#34;Returns the birth data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_birth_year(self):
        &#34;&#34;&#34;Returns the birth year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    def get_death_data(self):
        &#34;&#34;&#34;Returns the death data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    def get_death_year(self):
        &#34;&#34;&#34;Returns the death year of a person in integer format
        :rtype: int
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date_split = childOfChild.get_value().split()
                        date = date_split[len(date_split) - 1]

        if date == &#34;&#34;:
            return -1
        try:
            return int(date)
        except ValueError:
            return -1

    @deprecated
    def get_burial(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_burial_data()` method instead
        :rtype: tuple
        &#34;&#34;&#34;
        self.get_burial_data()

    def get_burial_data(self):
        &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
        :rtype: tuple
        &#34;&#34;&#34;
        date = &#34;&#34;
        place = &#34;&#34;
        sources = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_BURIAL:
                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

        return date, place, sources

    @deprecated
    def get_census(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        ::deprecated:: As of version 1.0.0 use `get_census_data()` method instead
        :rtype: list of tuple
        &#34;&#34;&#34;
        self.get_census_data()

    def get_census_data(self):
        &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
        :rtype: list of tuple
        &#34;&#34;&#34;
        census = []

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CENSUS:

                date = &#39;&#39;
                place = &#39;&#39;
                sources = []

                for childOfChild in child.get_child_elements():

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                        place = childOfChild.get_value()

                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        sources.append(childOfChild.get_value())

                census.append((date, place, sources))

        return census

    def get_last_change_date(self):
        &#34;&#34;&#34;Returns the date of when the person data was last changed formatted as a string
        :rtype: str
        &#34;&#34;&#34;
        date = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_CHANGE:
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                        date = childOfChild.get_value()

        return date

    def get_occupation(self):
        &#34;&#34;&#34;Returns the occupation of a person
        :rtype: str
        &#34;&#34;&#34;
        occupation = &#34;&#34;

        for child in self.get_child_elements():
            if child.get_tag() == gedcom.tags.GEDCOM_TAG_OCCUPATION:
                occupation = child.get_value()

        return occupation

    def birth_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the birth year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_birth_year() == year

    def birth_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the birth year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        birth_year = self.get_birth_year()

        if from_year &lt;= birth_year &lt;= to_year:
            return True

        return False

    def death_year_match(self, year):
        &#34;&#34;&#34;Returns `True` if the given year matches the death year of this person
        :type year: int
        :rtype: bool
        &#34;&#34;&#34;
        return self.get_death_year() == year

    def death_range_match(self, from_year, to_year):
        &#34;&#34;&#34;Checks if the death year of a person lies within the given range
        :type from_year: int
        :type to_year: int
        :rtype: bool
        &#34;&#34;&#34;
        death_year = self.get_death_year()

        if from_year &lt;= death_year &lt;= to_year:
            return True

        return False

    def criteria_match(self, criteria):
        &#34;&#34;&#34;Checks if this individual matches all of the given criteria

        `criteria` is a colon-separated list, where each item in the
        list has the form [name]=[value]. The following criteria are supported:

        surname=[name]
             Match a person with [name] in any part of the `surname`.
        given_name=[given_name]
             Match a person with [given_name] in any part of the given `given_name`.
        birth=[year]
             Match a person whose birth year is a four-digit [year].
        birth_range=[from_year-to_year]
             Match a person whose birth year is in the range of years from
             [from_year] to [to_year], including both [from_year] and [to_year].

        :type criteria: str
        :rtype: bool
        &#34;&#34;&#34;

        # Check if criteria is a valid criteria and can be split by `:` and `=` characters
        try:
            for criterion in criteria.split(&#39;:&#39;):
                criterion.split(&#39;=&#39;)
        except ValueError:
            return False

        match = True

        for criterion in criteria.split(&#39;:&#39;):
            key, value = criterion.split(&#39;=&#39;)

            if key == &#34;surname&#34; and not self.surname_match(value):
                match = False
            elif key == &#34;name&#34; and not self.given_name_match(value):
                match = False
            elif key == &#34;birth&#34;:

                try:
                    year = int(value)
                    if not self.birth_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;birth_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.birth_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death&#34;:

                try:
                    year = int(value)
                    if not self.death_year_match(year):
                        match = False
                except ValueError:
                    match = False

            elif key == &#34;death_range&#34;:

                try:
                    from_year, to_year = value.split(&#39;-&#39;)
                    from_year = int(from_year)
                    to_year = int(to_year)
                    if not self.death_range_match(from_year, to_year):
                        match = False
                except ValueError:
                    match = False

        return match</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gedcom.element.element.Element" href="element.html#gedcom.element.element.Element">Element</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gedcom.element.individual.IndividualElement.birth_range_match"><code class="name flex">
<span>def <span class="ident">birth_range_match</span></span>(<span>self, from_year, to_year)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the birth year of a person lies within the given range
:type from_year: int
:type to_year: int
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def birth_range_match(self, from_year, to_year):
    &#34;&#34;&#34;Checks if the birth year of a person lies within the given range
    :type from_year: int
    :type to_year: int
    :rtype: bool
    &#34;&#34;&#34;
    birth_year = self.get_birth_year()

    if from_year &lt;= birth_year &lt;= to_year:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.birth_year_match"><code class="name flex">
<span>def <span class="ident">birth_year_match</span></span>(<span>self, year)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns <code>True</code> if the given year matches the birth year of this person
:type year: int
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def birth_year_match(self, year):
    &#34;&#34;&#34;Returns `True` if the given year matches the birth year of this person
    :type year: int
    :rtype: bool
    &#34;&#34;&#34;
    return self.get_birth_year() == year</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.criteria_match"><code class="name flex">
<span>def <span class="ident">criteria_match</span></span>(<span>self, criteria)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if this individual matches all of the given criteria</p>
<p><code>criteria</code> is a colon-separated list, where each item in the
list has the form [name]=[value]. The following criteria are supported:</p>
<p>surname=[name]
Match a person with [name] in any part of the <code>surname</code>.
given_name=[given_name]
Match a person with [given_name] in any part of the given <code>given_name</code>.
birth=[year]
Match a person whose birth year is a four-digit [year].
birth_range=[from_year-to_year]
Match a person whose birth year is in the range of years from
[from_year] to [to_year], including both [from_year] and [to_year].</p>
<p>:type criteria: str
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def criteria_match(self, criteria):
    &#34;&#34;&#34;Checks if this individual matches all of the given criteria

    `criteria` is a colon-separated list, where each item in the
    list has the form [name]=[value]. The following criteria are supported:

    surname=[name]
         Match a person with [name] in any part of the `surname`.
    given_name=[given_name]
         Match a person with [given_name] in any part of the given `given_name`.
    birth=[year]
         Match a person whose birth year is a four-digit [year].
    birth_range=[from_year-to_year]
         Match a person whose birth year is in the range of years from
         [from_year] to [to_year], including both [from_year] and [to_year].

    :type criteria: str
    :rtype: bool
    &#34;&#34;&#34;

    # Check if criteria is a valid criteria and can be split by `:` and `=` characters
    try:
        for criterion in criteria.split(&#39;:&#39;):
            criterion.split(&#39;=&#39;)
    except ValueError:
        return False

    match = True

    for criterion in criteria.split(&#39;:&#39;):
        key, value = criterion.split(&#39;=&#39;)

        if key == &#34;surname&#34; and not self.surname_match(value):
            match = False
        elif key == &#34;name&#34; and not self.given_name_match(value):
            match = False
        elif key == &#34;birth&#34;:

            try:
                year = int(value)
                if not self.birth_year_match(year):
                    match = False
            except ValueError:
                match = False

        elif key == &#34;birth_range&#34;:

            try:
                from_year, to_year = value.split(&#39;-&#39;)
                from_year = int(from_year)
                to_year = int(to_year)
                if not self.birth_range_match(from_year, to_year):
                    match = False
            except ValueError:
                match = False

        elif key == &#34;death&#34;:

            try:
                year = int(value)
                if not self.death_year_match(year):
                    match = False
            except ValueError:
                match = False

        elif key == &#34;death_range&#34;:

            try:
                from_year, to_year = value.split(&#39;-&#39;)
                from_year = int(from_year)
                to_year = int(to_year)
                if not self.death_range_match(from_year, to_year):
                    match = False
            except ValueError:
                match = False

    return match</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.death_range_match"><code class="name flex">
<span>def <span class="ident">death_range_match</span></span>(<span>self, from_year, to_year)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the death year of a person lies within the given range
:type from_year: int
:type to_year: int
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def death_range_match(self, from_year, to_year):
    &#34;&#34;&#34;Checks if the death year of a person lies within the given range
    :type from_year: int
    :type to_year: int
    :rtype: bool
    &#34;&#34;&#34;
    death_year = self.get_death_year()

    if from_year &lt;= death_year &lt;= to_year:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.death_year_match"><code class="name flex">
<span>def <span class="ident">death_year_match</span></span>(<span>self, year)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns <code>True</code> if the given year matches the death year of this person
:type year: int
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def death_year_match(self, year):
    &#34;&#34;&#34;Returns `True` if the given year matches the death year of this person
    :type year: int
    :rtype: bool
    &#34;&#34;&#34;
    return self.get_death_year() == year</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_all_names"><code class="name flex">
<span>def <span class="ident">get_all_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_names(self):
    return [a.get_value() for a in self.get_child_elements() if a.get_tag() == gedcom.tags.GEDCOM_TAG_NAME]</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_birth_data"><code class="name flex">
<span>def <span class="ident">get_birth_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the birth data of a person formatted as a tuple: (<code>str</code> date, <code>str</code> place, <code>list</code> sources)
:rtype: tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_birth_data(self):
    &#34;&#34;&#34;Returns the birth data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
    :rtype: tuple
    &#34;&#34;&#34;
    date = &#34;&#34;
    place = &#34;&#34;
    sources = []

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
            for childOfChild in child.get_child_elements():

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                    place = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                    sources.append(childOfChild.get_value())

    return date, place, sources</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_birth_year"><code class="name flex">
<span>def <span class="ident">get_birth_year</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the birth year of a person in integer format
:rtype: int</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_birth_year(self):
    &#34;&#34;&#34;Returns the birth year of a person in integer format
    :rtype: int
    &#34;&#34;&#34;
    date = &#34;&#34;

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_BIRTH:
            for childOfChild in child.get_child_elements():
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date_split = childOfChild.get_value().split()
                    date = date_split[len(date_split) - 1]

    if date == &#34;&#34;:
        return -1
    try:
        return int(date)
    except ValueError:
        return -1</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_burial"><code class="name flex">
<span>def <span class="ident">get_burial</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the burial data of a person formatted as a tuple: (<code>str</code> date, <code>str´ place,</code>list<code>sources)
::deprecated:: As of version 1.0.0 use</code>get_burial_data()` method instead
:rtype: tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@deprecated
def get_burial(self):
    &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
    ::deprecated:: As of version 1.0.0 use `get_burial_data()` method instead
    :rtype: tuple
    &#34;&#34;&#34;
    self.get_burial_data()</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_burial_data"><code class="name flex">
<span>def <span class="ident">get_burial_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the burial data of a person formatted as a tuple: (<code>str</code> date, <code>str´ place,</code>list` sources)
:rtype: tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_burial_data(self):
    &#34;&#34;&#34;Returns the burial data of a person formatted as a tuple: (`str` date, `str´ place, `list` sources)
    :rtype: tuple
    &#34;&#34;&#34;
    date = &#34;&#34;
    place = &#34;&#34;
    sources = []

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_BURIAL:
            for childOfChild in child.get_child_elements():

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                    place = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                    sources.append(childOfChild.get_value())

    return date, place, sources</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_census"><code class="name flex">
<span>def <span class="ident">get_census</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of censuses of an individual formatted as tuples: (<code>str</code> date, <code>str´ place,</code>list<code>sources)
::deprecated:: As of version 1.0.0 use</code>get_census_data()` method instead
:rtype: list of tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@deprecated
def get_census(self):
    &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
    ::deprecated:: As of version 1.0.0 use `get_census_data()` method instead
    :rtype: list of tuple
    &#34;&#34;&#34;
    self.get_census_data()</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_census_data"><code class="name flex">
<span>def <span class="ident">get_census_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of censuses of an individual formatted as tuples: (<code>str</code> date, <code>str´ place,</code>list` sources)
:rtype: list of tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_census_data(self):
    &#34;&#34;&#34;Returns a list of censuses of an individual formatted as tuples: (`str` date, `str´ place, `list` sources)
    :rtype: list of tuple
    &#34;&#34;&#34;
    census = []

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_CENSUS:

            date = &#39;&#39;
            place = &#39;&#39;
            sources = []

            for childOfChild in child.get_child_elements():

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                    place = childOfChild.get_value()

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                    sources.append(childOfChild.get_value())

            census.append((date, place, sources))

    return census</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_death_data"><code class="name flex">
<span>def <span class="ident">get_death_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the death data of a person formatted as a tuple: (<code>str</code> date, <code>str</code> place, <code>list</code> sources)
:rtype: tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_death_data(self):
    &#34;&#34;&#34;Returns the death data of a person formatted as a tuple: (`str` date, `str` place, `list` sources)
    :rtype: tuple
    &#34;&#34;&#34;
    date = &#34;&#34;
    place = &#34;&#34;
    sources = []

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
            for childOfChild in child.get_child_elements():
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date = childOfChild.get_value()
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_PLACE:
                    place = childOfChild.get_value()
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                    sources.append(childOfChild.get_value())

    return date, place, sources</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_death_year"><code class="name flex">
<span>def <span class="ident">get_death_year</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the death year of a person in integer format
:rtype: int</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_death_year(self):
    &#34;&#34;&#34;Returns the death year of a person in integer format
    :rtype: int
    &#34;&#34;&#34;
    date = &#34;&#34;

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
            for childOfChild in child.get_child_elements():
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date_split = childOfChild.get_value().split()
                    date = date_split[len(date_split) - 1]

    if date == &#34;&#34;:
        return -1
    try:
        return int(date)
    except ValueError:
        return -1</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_gender"><code class="name flex">
<span>def <span class="ident">get_gender</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the gender of a person in string format
:rtype: str</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gender(self):
    &#34;&#34;&#34;Returns the gender of a person in string format
    :rtype: str
    &#34;&#34;&#34;
    gender = &#34;&#34;

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_SEX:
            gender = child.get_value()

    return gender</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_last_change_date"><code class="name flex">
<span>def <span class="ident">get_last_change_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the date of when the person data was last changed formatted as a string
:rtype: str</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_change_date(self):
    &#34;&#34;&#34;Returns the date of when the person data was last changed formatted as a string
    :rtype: str
    &#34;&#34;&#34;
    date = &#34;&#34;

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_CHANGE:
            for childOfChild in child.get_child_elements():
                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_DATE:
                    date = childOfChild.get_value()

    return date</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an individual's names as a tuple: (<code>str</code> given_name, <code>str</code> surname)
:rtype: tuple</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    &#34;&#34;&#34;Returns an individual&#39;s names as a tuple: (`str` given_name, `str` surname)
    :rtype: tuple
    &#34;&#34;&#34;
    given_name = &#34;&#34;
    surname = &#34;&#34;

    # Return the first gedcom.tags.GEDCOM_TAG_NAME that is found.
    # Alternatively as soon as we have both the gedcom.tags.GEDCOM_TAG_GIVEN_NAME and _SURNAME return those.
    found_given_name = False
    found_surname_name = False

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_NAME:
            # Some GEDCOM files don&#39;t use child tags but instead
            # place the name in the value of the NAME tag.
            if child.get_value() != &#34;&#34;:
                name = child.get_value().split(&#39;/&#39;)

                if len(name) &gt; 0:
                    given_name = name[0].strip()
                    if len(name) &gt; 1:
                        surname = name[1].strip()

                return given_name, surname

            for childOfChild in child.get_child_elements():

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_GIVEN_NAME:
                    given_name = childOfChild.get_value()
                    found_given_name = True

                if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SURNAME:
                    surname = childOfChild.get_value()
                    found_surname_name = True

            if found_given_name and found_surname_name:
                return given_name, surname

    # If we reach here we are probably returning empty strings
    return given_name, surname</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.get_occupation"><code class="name flex">
<span>def <span class="ident">get_occupation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the occupation of a person
:rtype: str</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_occupation(self):
    &#34;&#34;&#34;Returns the occupation of a person
    :rtype: str
    &#34;&#34;&#34;
    occupation = &#34;&#34;

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_OCCUPATION:
            occupation = child.get_value()

    return occupation</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.given_match"><code class="name flex">
<span>def <span class="ident">given_match</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Matches a string with the given name of an individual
::deprecated:: As of version 1.0.0 use <code>given_name_match()</code> method instead
:type name: str
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@deprecated
def given_match(self, name):
    &#34;&#34;&#34;Matches a string with the given name of an individual
    ::deprecated:: As of version 1.0.0 use `given_name_match()` method instead
    :type name: str
    :rtype: bool
    &#34;&#34;&#34;
    return self.given_name_match(name)</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.given_name_match"><code class="name flex">
<span>def <span class="ident">given_name_match</span></span>(<span>self, given_name_to_match)</span>
</code></dt>
<dd>
<section class="desc"><p>Matches a string with the given name of an individual
:type given_name_to_match: str
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def given_name_match(self, given_name_to_match):
    &#34;&#34;&#34;Matches a string with the given name of an individual
    :type given_name_to_match: str
    :rtype: bool
    &#34;&#34;&#34;
    (given_name, surname) = self.get_name()
    return regex.search(given_name_to_match, given_name, regex.IGNORECASE)</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_child"><code class="name flex">
<span>def <span class="ident">is_child</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if this element is a child of a family
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_child(self):
    &#34;&#34;&#34;Checks if this element is a child of a family
    :rtype: bool
    &#34;&#34;&#34;
    found_child = False

    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_FAMILY_CHILD:
            found_child = True

    return found_child</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_deceased"><code class="name flex">
<span>def <span class="ident">is_deceased</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if this individual is deceased
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_deceased(self):
    &#34;&#34;&#34;Checks if this individual is deceased
    :rtype: bool
    &#34;&#34;&#34;
    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_DEATH:
            return True

    return False</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.is_private"><code class="name flex">
<span>def <span class="ident">is_private</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if this individual is marked private
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_private(self):
    &#34;&#34;&#34;Checks if this individual is marked private
    :rtype: bool
    &#34;&#34;&#34;
    for child in self.get_child_elements():
        if child.get_tag() == gedcom.tags.GEDCOM_TAG_PRIVATE:
            private = child.get_value()
            if private == &#39;Y&#39;:
                return True

    return False</code></pre>
</details>
</dd>
<dt id="gedcom.element.individual.IndividualElement.surname_match"><code class="name flex">
<span>def <span class="ident">surname_match</span></span>(<span>self, surname_to_match)</span>
</code></dt>
<dd>
<section class="desc"><p>Matches a string with the surname of an individual
:type surname_to_match: str
:rtype: bool</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surname_match(self, surname_to_match):
    &#34;&#34;&#34;Matches a string with the surname of an individual
    :type surname_to_match: str
    :rtype: bool
    &#34;&#34;&#34;
    (given_name, surname) = self.get_name()
    return regex.search(surname_to_match, surname, regex.IGNORECASE)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gedcom.element.element.Element" href="element.html#gedcom.element.element.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="gedcom.element.element.Element.add_child_element" href="element.html#gedcom.element.element.Element.add_child_element">add_child_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_child_elements" href="element.html#gedcom.element.element.Element.get_child_elements">get_child_elements</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_individual" href="element.html#gedcom.element.element.Element.get_individual">get_individual</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_level" href="element.html#gedcom.element.element.Element.get_level">get_level</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_multi_line_value" href="element.html#gedcom.element.element.Element.get_multi_line_value">get_multi_line_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_parent_element" href="element.html#gedcom.element.element.Element.get_parent_element">get_parent_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_pointer" href="element.html#gedcom.element.element.Element.get_pointer">get_pointer</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_tag" href="element.html#gedcom.element.element.Element.get_tag">get_tag</a></code></li>
<li><code><a title="gedcom.element.element.Element.get_value" href="element.html#gedcom.element.element.Element.get_value">get_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.new_child_element" href="element.html#gedcom.element.element.Element.new_child_element">new_child_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_multi_line_value" href="element.html#gedcom.element.element.Element.set_multi_line_value">set_multi_line_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_parent_element" href="element.html#gedcom.element.element.Element.set_parent_element">set_parent_element</a></code></li>
<li><code><a title="gedcom.element.element.Element.set_value" href="element.html#gedcom.element.element.Element.set_value">set_value</a></code></li>
<li><code><a title="gedcom.element.element.Element.to_gedcom_string" href="element.html#gedcom.element.element.Element.to_gedcom_string">to_gedcom_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gedcom.element.individual.NotAnActualIndividualError"><code class="flex name class">
<span>class <span class="ident">NotAnActualIndividualError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<section class="desc"><p>Common base class for all non-exit exceptions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotAnActualIndividualError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gedcom.element" href="index.html">gedcom.element</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gedcom.element.individual.IndividualElement" href="#gedcom.element.individual.IndividualElement">IndividualElement</a></code></h4>
<ul class="">
<li><code><a title="gedcom.element.individual.IndividualElement.birth_range_match" href="#gedcom.element.individual.IndividualElement.birth_range_match">birth_range_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.birth_year_match" href="#gedcom.element.individual.IndividualElement.birth_year_match">birth_year_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.criteria_match" href="#gedcom.element.individual.IndividualElement.criteria_match">criteria_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.death_range_match" href="#gedcom.element.individual.IndividualElement.death_range_match">death_range_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.death_year_match" href="#gedcom.element.individual.IndividualElement.death_year_match">death_year_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_all_names" href="#gedcom.element.individual.IndividualElement.get_all_names">get_all_names</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_birth_data" href="#gedcom.element.individual.IndividualElement.get_birth_data">get_birth_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_birth_year" href="#gedcom.element.individual.IndividualElement.get_birth_year">get_birth_year</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_burial" href="#gedcom.element.individual.IndividualElement.get_burial">get_burial</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_burial_data" href="#gedcom.element.individual.IndividualElement.get_burial_data">get_burial_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_census" href="#gedcom.element.individual.IndividualElement.get_census">get_census</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_census_data" href="#gedcom.element.individual.IndividualElement.get_census_data">get_census_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_death_data" href="#gedcom.element.individual.IndividualElement.get_death_data">get_death_data</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_death_year" href="#gedcom.element.individual.IndividualElement.get_death_year">get_death_year</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_gender" href="#gedcom.element.individual.IndividualElement.get_gender">get_gender</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_last_change_date" href="#gedcom.element.individual.IndividualElement.get_last_change_date">get_last_change_date</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_name" href="#gedcom.element.individual.IndividualElement.get_name">get_name</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.get_occupation" href="#gedcom.element.individual.IndividualElement.get_occupation">get_occupation</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.given_match" href="#gedcom.element.individual.IndividualElement.given_match">given_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.given_name_match" href="#gedcom.element.individual.IndividualElement.given_name_match">given_name_match</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_child" href="#gedcom.element.individual.IndividualElement.is_child">is_child</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_deceased" href="#gedcom.element.individual.IndividualElement.is_deceased">is_deceased</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.is_private" href="#gedcom.element.individual.IndividualElement.is_private">is_private</a></code></li>
<li><code><a title="gedcom.element.individual.IndividualElement.surname_match" href="#gedcom.element.individual.IndividualElement.surname_match">surname_match</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gedcom.element.individual.NotAnActualIndividualError" href="#gedcom.element.individual.NotAnActualIndividualError">NotAnActualIndividualError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>